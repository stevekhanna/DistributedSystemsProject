Fri Jan 22 16:55:31 MST 2021
java

Fri Jan 22 16:56:26 MST 2021
java

Fri Jan 22 17:04:34 MST 2021
java

Fri Jan 22 17:06:47 MST 2021
java

Fri Jan 22 17:07:40 MST 2021
java

Fri Jan 22 17:10:21 MST 2021
java

Fri Jan 22 17:15:00 MST 2021
java
灡捫慧攠䍬楥湴㬊੩浰潲琠橡癡⹩漮⨻੩浰潲琠橡癡⹮整⹓潣步琻੩浰潲琠橡癡⹮楯⹣桡牳整⹓瑡湤慲摃桡牳整猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥卹獴敭猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥猻੩浰潲琠橡癡⹮楯⹦楬攮偡瑨㬊業灯牴⁪慶愮湩漮晩汥⹐慴桳㬊ੰ畢汩挠捬慳猠䍬楥湴⁻ਠ†⁰物癡瑥⁓瑲楮朠獥牶敲䥐‽•汯捡汨潳琢㬊††灲楶慴攠楮琠灯牴‽‱㈳㐵㬊ਠ†⁂畦晥牥摒敡摥爠牥慤敲㬊††䉵晦敲敤坲楴敲⁷物瑥爻ਠ†⁰畢汩挠䍬楥湴⡓瑲楮朠獥牶敲䥐Ⱐ楮琠灯牴⥻ਠ†††⁴桩献獥牶敲䥐‽⁳敲癥牉倻ਠ†††⁴桩献灯牴‽⁰潲琻ਠ†⁽ਊ††灲楶慴攠癯楤⁨慮摬敒敱略獴⡓潣步琠獯捫⥻ਊ††††瑲祻ਠ†††††⁲敡摥爠㴠湥眠䉵晦敲敤剥慤敲⡮敷⁉湰畴却牥慭剥慤敲⡳潣欮来瑉湰畴却牥慭⠩⤩㬊††††††睲楴敲‽⁮敷⁂畦晥牥摗物瑥爨湥眠併瑰畴却牥慭坲楴敲⡳潣欮来瑏畴灵瑓瑲敡洨⤩⤻ਠ†††††⁓瑲楮朠牥煵敳琻ਠ†††††⁷桩汥 ⡲敱略獴‽⁲敡摥爮牥慤䱩湥⠩⤠ℽ⁮畬氩笊††††††††卹獴敭⹯畴⹰物湴汮⡲敱略獴⤻ਠ†††††††⁓瑲楮朠牥獰潮獥‽•∻ਊ††††††††獷楴捨⡲敱略獴⤠笊††††††††††捡獥•来琠瑥慭⁮慭攢㨊††††††††††††牥獰潮獥‽•却敶攠慮搠䥳獡捫屮∻ਠ†††††††††††⁓祳瑥洮潵琮灲楮瑬渨≗物瑩湧⁲敳灯湳攠湯眺•‫⁲敳灯湳攩㬊††††††††††††睲楴敲⹷物瑥⡲敳灯湳攩㬊††††††††††††睲楴敲⹦汵獨⠩㬊††††††††††††扲敡欻ਠ†††††††††⁣慳攠≧整⁣潤攢㨊††††††††††††却物湧⁬慮杵慧攠㴠≪慶慜渢㬊ਠ†††††††††††⁐慴栠灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨≳牣∩㬊††††††††††††却物湧⁳‽⁰慴栮瑯䅢獯汵瑥偡瑨⠩⹴潓瑲楮木⤻ਠ†††††††††††⁩映⡳⹣潮瑡楮猨∯∩⥻猫㴢⼢㭽敬獥筳⬽≜尢㭽ਠ†††††††††††⁰慴栠㴠䙩汥卹獴敭献来瑄敦慵汴⠩⹧整偡瑨⡳⬢䍬楥湴∩㬊††††††††††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††††††††††楦 献捯湴慩湳⠢⼢⤩筳⬽∯∻絥汳敻猫㴢屜∻紊††††††††††††灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨猫≃汩敮琮橡癡∩㬊††††††††††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††††††††††卹獴敭⹯畴⹰物湴汮⠢䍵牲敮琠牥污瑩癥⁰慴栠楳㨠∠⬠猩㬊ਯ⼠†††††††††††⁐慴栠灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨∢⤮瑯䅢獯汵瑥偡瑨⠩㬊⼯††††††††††††卹獴敭⹯畴⹰物湴汮⡰慴栮瑯却物湧⠩⤻ਯ⼠†††††††††††⁓瑲楮朠捯摥‽⁆楬敳⹲敡摓瑲楮木灡瑨Ⱐ却慮摡牤䍨慲獥瑳⹕呆弱㘩㬊††††††††††††却物湧⁣潤攠㴠䙩汥献牥慤却物湧⡰慴栬⁓瑡湤慲摃桡牳整献啔䙟ㄶ⤫≜渢㬊††††††††††††却物湧⁥湤佦䍯摥‽•⸮⹜渢㬊††††††††††††牥獰潮獥‽⁬慮杵慧攫捯摥⭥湤佦䍯摥㬊††††††††††††睲楴敲⹷物瑥⡲敳灯湳攩㬊††††††††††††睲楴敲⹦汵獨⠩㬊††††††††††††扲敡欻ਠ†††††††††⁤敦慵汴㨊††††††††††††卹獴敭⹯畴⹰物湴汮⠢剥煵敳琠湯琠牥捯杮楺敤∩㬊††††††††紊††††††紊††††††牥慤敲⹣汯獥⠩㬊††††††睲楴敲⹣汯獥⠩㬊††††紊††††捡瑣栨䥏䕸捥灴楯渠攩笊††††††攮灲楮瑓瑡捫呲慣攨⤻ਊ††††紊††紊ਊ††灵扬楣⁶潩搠獴慲琨⤠瑨牯睳⁉佅硣数瑩潮笊ਠ†††⁓潣步琠獯捫‽⁮敷⁓潣步琨獥牶敲䥐Ⱐ灯牴⤻ਠ†††⁨慮摬敒敱略獴⡳潣欩㬊††††獯捫⹣汯獥⠩㬊ਊ††紊紊
Fri Jan 22 17:15:42 MST 2021
java
灡捫慧攠䍬楥湴㬊੩浰潲琠橡癡⹩漮⨻੩浰潲琠橡癡⹮整⹓潣步琻੩浰潲琠橡癡⹮楯⹣桡牳整⹓瑡湤慲摃桡牳整猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥卹獴敭猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥猻੩浰潲琠橡癡⹮楯⹦楬攮偡瑨㬊業灯牴⁪慶愮湩漮晩汥⹐慴桳㬊ੰ畢汩挠捬慳猠䍬楥湴⁻ਠ†⁰物癡瑥⁓瑲楮朠獥牶敲䥐‽•汯捡汨潳琢㬊††灲楶慴攠楮琠灯牴‽‱㈳㐵㬊ਠ†⁂畦晥牥摒敡摥爠牥慤敲㬊††䉵晦敲敤坲楴敲⁷物瑥爻ਠ†⁰畢汩挠䍬楥湴⡓瑲楮朠獥牶敲䥐Ⱐ楮琠灯牴⥻ਠ†††⁴桩献獥牶敲䥐‽⁳敲癥牉倻ਠ†††⁴桩献灯牴‽⁰潲琻ਠ†⁽ਊ††灲楶慴攠癯楤⁨慮摬敒敱略獴⡓潣步琠獯捫⥻ਊ††††瑲祻ਠ†††††⁲敡摥爠㴠湥眠䉵晦敲敤剥慤敲⡮敷⁉湰畴却牥慭剥慤敲⡳潣欮来瑉湰畴却牥慭⠩⤩㬊††††††睲楴敲‽⁮敷⁂畦晥牥摗物瑥爨湥眠併瑰畴却牥慭坲楴敲⡳潣欮来瑏畴灵瑓瑲敡洨⤩⤻ਠ†††††⁓瑲楮朠牥煵敳琻ਠ†††††⁷桩汥 ⡲敱略獴‽⁲敡摥爮牥慤䱩湥⠩⤠ℽ⁮畬氩笊††††††††卹獴敭⹯畴⹰物湴汮⡲敱略獴⤻ਠ†††††††⁓瑲楮朠牥獰潮獥‽•∻ਊ††††††††獷楴捨⡲敱略獴⤠笊††††††††††捡獥•来琠瑥慭⁮慭攢㨊††††††††††††牥獰潮獥‽•却敶攠慮搠䥳獡捫屮∻ਠ†††††††††††⁓祳瑥洮潵琮灲楮瑬渨≗物瑩湧⁲敳灯湳攠湯眺•‫⁲敳灯湳攩㬊††††††††††††睲楴敲⹷物瑥⡲敳灯湳攩㬊††††††††††††睲楴敲⹦汵獨⠩㬊††††††††††††扲敡欻ਠ†††††††††⁣慳攠≧整⁣潤攢㨊††††††††††††却物湧⁬慮杵慧攠㴠≪慶慜渢㬊ਠ†††††††††††⁐慴栠灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨≳牣∩㬊††††††††††††却物湧⁳‽⁰慴栮瑯䅢獯汵瑥偡瑨⠩⹴潓瑲楮木⤻ਠ†††††††††††⁩映⡳⹣潮瑡楮猨∯∩⥻猫㴢⼢㭽敬獥筳⬽≜尢㭽ਠ†††††††††††⁰慴栠㴠䙩汥卹獴敭献来瑄敦慵汴⠩⹧整偡瑨⡳⬢䍬楥湴∩㬊††††††††††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††††††††††楦 献捯湴慩湳⠢⼢⤩筳⬽∯∻絥汳敻猫㴢屜∻紊††††††††††††灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨猫≃汩敮琮橡癡∩㬊††††††††††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††††††††††卹獴敭⹯畴⹰物湴汮⠢䍵牲敮琠牥污瑩癥⁰慴栠楳㨠∠⬠猩㬊ਯ⼠†††††††††††⁐慴栠灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨∢⤮瑯䅢獯汵瑥偡瑨⠩㬊⼯††††††††††††卹獴敭⹯畴⹰物湴汮⡰慴栮瑯却物湧⠩⤻ਯ⼠†††††††††††⁓瑲楮朠捯摥‽⁆楬敳⹲敡摓瑲楮木灡瑨Ⱐ却慮摡牤䍨慲獥瑳⹕呆弱㘩㬊††††††††††††却物湧⁣潤攠㴠䙩汥献牥慤却物湧⡰慴栬⁓瑡湤慲摃桡牳整献啔䙟ㄶ⤫≜渢㬊††††††††††††卹獴敭⹯畴⹰物湴汮⡣潤攩㬊††††††††††††却物湧⁥湤佦䍯摥‽•⸮⹜渢㬊††††††††††††牥獰潮獥‽⁬慮杵慧攫捯摥⭥湤佦䍯摥㬊††††††††††††睲楴敲⹷物瑥⡲敳灯湳攩㬊††††††††††††睲楴敲⹦汵獨⠩㬊††††††††††††扲敡欻ਠ†††††††††⁤敦慵汴㨊††††††††††††卹獴敭⹯畴⹰物湴汮⠢剥煵敳琠湯琠牥捯杮楺敤∩㬊††††††††紊††††††紊††††††牥慤敲⹣汯獥⠩㬊††††††睲楴敲⹣汯獥⠩㬊††††紊††††捡瑣栨䥏䕸捥灴楯渠攩笊††††††攮灲楮瑓瑡捫呲慣攨⤻ਊ††††紊††紊ਊ††灵扬楣⁶潩搠獴慲琨⤠瑨牯睳⁉佅硣数瑩潮笊ਠ†††⁓潣步琠獯捫‽⁮敷⁓潣步琨獥牶敲䥐Ⱐ灯牴⤻ਠ†††⁨慮摬敒敱略獴⡳潣欩㬊††††獯捫⹣汯獥⠩㬊ਊ††紊紊
Fri Jan 22 17:17:17 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                        break;
                    case "get code":
                        String language = "java\n";

                        Path path = FileSystems.getDefault().getPath("src");
                        String s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client");
                        s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client.java");
                        s = path.toAbsolutePath().toString();
                        System.out.println("Current relative path is: " + s);

//                        Path path = FileSystems.getDefault().getPath("").toAbsolutePath();
//                        System.out.println(path.toString());
//                        String code = Files.readString(path, StandardCharsets.UTF_16);
                        String code = Files.readString(path, StandardCharsets.US_ASCII)+"\n";
                        System.out.println(code);
                        String endOfCode = "...\n";
                        response = language+code+endOfCode;
                        writer.write(response);
                        writer.flush();
                        break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 15:45:15 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        String language = "java\n";

                        Path path = FileSystems.getDefault().getPath("src");
                        String s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client");
                        s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client.java");
                        s = path.toAbsolutePath().toString();
                        System.out.println("Current relative path is: " + s);

                        String code = Files.readString(path, StandardCharsets.US_ASCII)+"\n";
                        System.out.println(code);

                        String endOfCode = "...\n";
                        response = language+code+endOfCode;
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":

                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 15:51:59 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":

                        Path p = Paths.get("Client.java");
                        Path folder = FileSystems.getDefault().getPath(new String("./")).toAbsolutePath().getParent();

                        System.out.println(folder.toString());



                        String language = "java\n";

                        Path path = FileSystems.getDefault().getPath("src");
                        String s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client");
                        s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client.java");
                        s = path.toAbsolutePath().toString();
                        System.out.println("Current relative path is: " + s);

                        String code = Files.readString(path, StandardCharsets.US_ASCII)+"\n";
                        System.out.println(code);

                        String endOfCode = "...\n";
                        response = language+code+endOfCode;
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":

                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 16:12:28 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":

                        Path p = Paths.get("Client.java");
                        Path folder = FileSystems.getDefault().getPath(new String("./")).toAbsolutePath().getParent();

                        System.out.println(folder.toString());



                        String language = "java\n";

                        Path path = FileSystems.getDefault().getPath("src");
                        String s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client");
                        s = path.toAbsolutePath().toString();
                        if (s.contains("/")){s+="/";}else{s+="\\";}
                        path = FileSystems.getDefault().getPath(s+"Client.java");
                        s = path.toAbsolutePath().toString();
                        System.out.println("Current relative path is: " + s);

                        String code = Files.readString(path)+"\n";
                        System.out.println(code);

                        String endOfCode = "...\n";
                        response = language+code+endOfCode;
                        writer.write(response);
                        writer.flush();

                    break;
                    case "receive peers":

                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 18:10:23 MST 2021
java
灡捫慧攠䍬楥湴㬊੩浰潲琠橡癡⹩漮⨻੩浰潲琠橡癡⹮整⹓潣步琻੩浰潲琠橡癡⹮楯⹣桡牳整⹓瑡湤慲摃桡牳整猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥卹獴敭猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥猻੩浰潲琠橡癡⹮楯⹦楬攮偡瑨㬊業灯牴⁪慶愮湩漮晩汥⹐慴桳㬊ੰ畢汩挠捬慳猠䍬楥湴⁻ਠ†⁰物癡瑥⁓瑲楮朠獥牶敲䥐‽•汯捡汨潳琢㬊††灲楶慴攠楮琠灯牴‽‱㈳㐵㬊ਠ†⁂畦晥牥摒敡摥爠牥慤敲㬊††䉵晦敲敤坲楴敲⁷物瑥爻ਠ†⁰畢汩挠䍬楥湴⡓瑲楮朠獥牶敲䥐Ⱐ楮琠灯牴⥻ਠ†††⁴桩献獥牶敲䥐‽⁳敲癥牉倻ਠ†††⁴桩献灯牴‽⁰潲琻ਠ†⁽ਊਠ†⁰物癡瑥⁓瑲楮朠桡湤汥䝥瑃潤攨⥻ਊ††††却物湧⁲敳灯湳攠㴠∢㬊††††却物湧⁬慮杵慧攠㴠≪慶慜渢㬊ਠ†††⁐慴栠灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨≳牣∩㬊††††却物湧⁳‽⁰慴栮瑯䅢獯汵瑥偡瑨⠩⹴潓瑲楮木⤻ਠ†††⁩映⡳⹣潮瑡楮猨∯∩⥻猫㴢⼢㭽敬獥筳⬽≜尢㭽ਠ†††⁰慴栠㴠䙩汥卹獴敭献来瑄敦慵汴⠩⹧整偡瑨⡳⬢䍬楥湴∩㬊††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††楦 献捯湴慩湳⠢⼢⤩筳⬽∯∻絥汳敻猫㴢屜∻紊††††灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨猫≃汩敮琮橡癡∩㬊††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††卹獴敭⹯畴⹰物湴汮⠢䍵牲敮琠牥污瑩癥⁰慴栠楳㨠∠⬠猩㬊ਠ†††⁴特笊††††††却物湧⁣潤攠㴠䙩汥献牥慤却物湧⡰慴栬⁓瑡湤慲摃桡牳整献啔䙟ㄶ⤫≜渢㬊††††††却物湧⁥湤佦䍯摥‽•⸮⹜渢㬊††††††牥獰潮獥‽⁬慮杵慧攫捯摥⭥湤佦䍯摥㬊††††紊††††捡瑣栨䥏䕸捥灴楯渠攩笊††††††攮灲楮瑓瑡捫呲慣攨⤻ਠ†††⁽ਊ††††牥瑵牮⁲敳灯湳攻ਠ†⁽ਊ††灲楶慴攠癯楤⁨慮摬敒敱略獴⡓潣步琠獯捫⥻ਊ††††瑲祻ਠ†††††⁲敡摥爠㴠湥眠䉵晦敲敤剥慤敲⡮敷⁉湰畴却牥慭剥慤敲⡳潣欮来瑉湰畴却牥慭⠩⤩㬊††††††睲楴敲‽⁮敷⁂畦晥牥摗物瑥爨湥眠併瑰畴却牥慭坲楴敲⡳潣欮来瑏畴灵瑓瑲敡洨⤩⤻ਠ†††††⁓瑲楮朠牥煵敳琻ਠ†††††⁷桩汥 ⡲敱略獴‽⁲敡摥爮牥慤䱩湥⠩⤠ℽ⁮畬氩笊††††††††卹獴敭⹯畴⹰物湴汮⡲敱略獴⤻ਠ†††††††⁓瑲楮朠牥獰潮獥‽•∻ਊ††††††††獷楴捨⡲敱略獴⤠笊††††††††††捡獥•来琠瑥慭⁮慭攢㨊††††††††††††牥獰潮獥‽•却敶攠慮搠䥳獡捫屮∻ਠ†††††††††††⁓祳瑥洮潵琮灲楮瑬渨≗物瑩湧⁲敳灯湳攠湯眺•‫⁲敳灯湳攩㬊††††††††††††睲楴敲⹷物瑥⡲敳灯湳攩㬊††††††††††††睲楴敲⹦汵獨⠩㬊††††††††††扲敡欻ਠ†††††††††⁣慳攠≧整⁣潤攢㨊ਠ†††††††††††⁲敳灯湳攠㴠桡湤汥䝥瑃潤攨⤻ਊਠ†††††††††††⁷物瑥爮睲楴攨牥獰潮獥⤻ਠ†††††††††††⁷物瑥爮晬畳栨⤻ਊ††††††††††扲敡欻ਠ†††††††††⁣慳攠≲散敩癥⁰敥牳∺ਊ††††††††††扲敡欻ਠ†††††††††⁤敦慵汴㨊††††††††††††卹獴敭⹯畴⹰物湴汮⠢剥煵敳琠湯琠牥捯杮楺敤∩㬊††††††††紊††††††紊††††††牥慤敲⹣汯獥⠩㬊††††††睲楴敲⹣汯獥⠩㬊††††紊††††捡瑣栨䥏䕸捥灴楯渠攩笊††††††攮灲楮瑓瑡捫呲慣攨⤻ਊ††††紊††紊ਊ††灵扬楣⁶潩搠獴慲琨⤠瑨牯睳⁉佅硣数瑩潮笊ਠ†††⁓潣步琠獯捫‽⁮敷⁓潣步琨獥牶敲䥐Ⱐ灯牴⤻ਠ†††⁨慮摬敒敱略獴⡳潣欩㬊††††獯捫⹣汯獥⠩㬊ਊ††紊紊
Sat Jan 23 18:11:02 MST 2021
java
灡捫慧攠䍬楥湴㬊੩浰潲琠橡癡⹩漮⨻੩浰潲琠橡癡⹮整⹓潣步琻੩浰潲琠橡癡⹮楯⹣桡牳整⹓瑡湤慲摃桡牳整猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥卹獴敭猻੩浰潲琠橡癡⹮楯⹦楬攮䙩汥猻੩浰潲琠橡癡⹮楯⹦楬攮偡瑨㬊業灯牴⁪慶愮湩漮晩汥⹐慴桳㬊ੰ畢汩挠捬慳猠䍬楥湴⁻ਠ†⁰物癡瑥⁓瑲楮朠獥牶敲䥐‽•汯捡汨潳琢㬊††灲楶慴攠楮琠灯牴‽‱㈳㐵㬊ਠ†⁂畦晥牥摒敡摥爠牥慤敲㬊††䉵晦敲敤坲楴敲⁷物瑥爻ਠ†⁰畢汩挠䍬楥湴⡓瑲楮朠獥牶敲䥐Ⱐ楮琠灯牴⥻ਠ†††⁴桩献獥牶敲䥐‽⁳敲癥牉倻ਠ†††⁴桩献灯牴‽⁰潲琻ਠ†⁽ਊਠ†⁰物癡瑥⁓瑲楮朠桡湤汥䝥瑃潤攨⥻ਊ††††却物湧⁲敳灯湳攠㴠∢㬊††††却物湧⁬慮杵慧攠㴠≪慶慜渢㬊ਠ†††⁐慴栠灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨≳牣∩㬊††††却物湧⁳‽⁰慴栮瑯䅢獯汵瑥偡瑨⠩⹴潓瑲楮木⤻ਠ†††⁩映⡳⹣潮瑡楮猨∯∩⥻猫㴢⼢㭽敬獥筳⬽≜尢㭽ਠ†††⁰慴栠㴠䙩汥卹獴敭献来瑄敦慵汴⠩⹧整偡瑨⡳⬢䍬楥湴∩㬊††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††楦 献捯湴慩湳⠢⼢⤩筳⬽∯∻絥汳敻猫㴢屜∻紊††††灡瑨‽⁆楬敓祳瑥浳⹧整䑥晡畬琨⤮来瑐慴栨猫≃汩敮琮橡癡∩㬊††††猠㴠灡瑨⹴潁扳潬畴敐慴栨⤮瑯却物湧⠩㬊††††卹獴敭⹯畴⹰物湴汮⠢䍵牲敮琠牥污瑩癥⁰慴栠楳㨠∠⬠猩㬊ਠ†††⁴特笊††††††却物湧⁣潤攠㴠䙩汥献牥慤却物湧⡰慴栬⁓瑡湤慲摃桡牳整献啔䙟ㄶ⤫≜渢㬊††††††却物湧⁥湤佦䍯摥‽•⸮⹜渢㬊††††††牥獰潮獥‽⁬慮杵慧攫捯摥⭥湤佦䍯摥㬊††††紊††††捡瑣栨䥏䕸捥灴楯渠攩笊††††††攮灲楮瑓瑡捫呲慣攨⤻ਠ†††⁽ਊ††††牥瑵牮⁲敳灯湳攻ਠ†⁽ਊ††灲楶慴攠癯楤⁨慮摬敒敱略獴⡓潣步琠獯捫⥻ਊ††††瑲祻ਠ†††††⁲敡摥爠㴠湥眠䉵晦敲敤剥慤敲⡮敷⁉湰畴却牥慭剥慤敲⡳潣欮来瑉湰畴却牥慭⠩⤩㬊††††††睲楴敲‽⁮敷⁂畦晥牥摗物瑥爨湥眠併瑰畴却牥慭坲楴敲⡳潣欮来瑏畴灵瑓瑲敡洨⤩⤻ਠ†††††⁓瑲楮朠牥煵敳琻ਠ†††††⁷桩汥 ⡲敱略獴‽⁲敡摥爮牥慤䱩湥⠩⤠ℽ⁮畬氩笊††††††††卹獴敭⹯畴⹰物湴汮⡲敱略獴⤻ਠ†††††††⁓瑲楮朠牥獰潮獥‽•∻ਊ††††††††獷楴捨⡲敱略獴⤠笊††††††††††捡獥•来琠瑥慭⁮慭攢㨊††††††††††††牥獰潮獥‽•却敶攠慮搠䥳獡捫屮∻ਠ†††††††††††⁓祳瑥洮潵琮灲楮瑬渨≗物瑩湧⁲敳灯湳攠湯眺•‫⁲敳灯湳攩㬊††††††††††††睲楴敲⹷物瑥⡲敳灯湳攩㬊††††††††††††睲楴敲⹦汵獨⠩㬊††††††††††扲敡欻ਠ†††††††††⁣慳攠≧整⁣潤攢㨊ਠ†††††††††††⁲敳灯湳攠㴠桡湤汥䝥瑃潤攨⤻ਠ†††††††††††⁓祳瑥洮潵琮灲楮瑬渨牥獰潮獥⤻ਠ†††††††††††⁷物瑥爮睲楴攨牥獰潮獥⤻ਠ†††††††††††⁷物瑥爮晬畳栨⤻ਊ††††††††††扲敡欻ਠ†††††††††⁣慳攠≲散敩癥⁰敥牳∺ਊ††††††††††扲敡欻ਠ†††††††††⁤敦慵汴㨊††††††††††††卹獴敭⹯畴⹰物湴汮⠢剥煵敳琠湯琠牥捯杮楺敤∩㬊††††††††紊††††††紊††††††牥慤敲⹣汯獥⠩㬊††††††睲楴敲⹣汯獥⠩㬊††††紊††††捡瑣栨䥏䕸捥灴楯渠攩笊††††††攮灲楮瑓瑡捫呲慣攨⤻ਊ††††紊††紊ਊ††灵扬楣⁶潩搠獴慲琨⤠瑨牯睳⁉佅硣数瑩潮笊ਠ†††⁓潣步琠獯捫‽⁮敷⁓潣步琨獥牶敲䥐Ⱐ灯牴⤻ਠ†††⁨慮摬敒敱略獴⡳潣欩㬊††††獯捫⹣汯獥⠩㬊ਊ††紊紊
Sat Jan 23 18:11:32 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":

                        response = handleGetCode();
                        System.out.println(response);
                        writer.write(response);
                        writer.flush();

                    break;
                    case "receive peers":

                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 18:21:43 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            System.out.println(peer);
                            numberOfPeers--;
                        }
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 18:22:38 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        //System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            System.out.println(peer);
                            numberOfPeers--;
                        }
                    break;
                    case "get report":

                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 18:22:49 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        //System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            System.out.println(peer);
                            numberOfPeers--;
                        }
                    break;
                    case "get report":

                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 18:48:17 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    List<String> peerList;
    ConcurrentHashMap<String, List<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerList = Collections.synchronizedList( new ArrayList<String>());
        this.peerTable = new ConcurrentHashMap<String, List<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        //System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().toString();

                        System.out.println(source);
                    break;
                    case "get report":
                        int numOfPeers = peerList.size();

                        String peers = peerList.toString();



                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 18:48:47 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    List<String> peerList;
    ConcurrentHashMap<String, List<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerList = Collections.synchronizedList( new ArrayList<String>());
        this.peerTable = new ConcurrentHashMap<String, List<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        //System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();

                        System.out.println(source);
                    break;
                    case "get report":
                        int numOfPeers = peerList.size();

                        String peers = peerList.toString();



                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 19:00:24 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, List<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;

        this.peerTable = new ConcurrentHashMap<String, List<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        //System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        List<String> peerList = Collections.synchronizedList( new ArrayList<String>());
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            List<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
//                            peerTable.put(source, temp);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 19:01:26 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, List<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;

        this.peerTable = new ConcurrentHashMap<String, List<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        //System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        List<String> peerList = Collections.synchronizedList( new ArrayList<String>());
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getLocalSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            List<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
//                            peerTable.put(source, temp);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sat Jan 23 19:02:14 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, List<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;

        this.peerTable = new ConcurrentHashMap<String, List<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        //System.out.println(response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        List<String> peerList = Collections.synchronizedList( new ArrayList<String>());
                        while(numberOfPeers >0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            List<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
//                            peerTable.put(source, temp);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();

        }
    }


    public void start() throws IOException{

        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();


    }
}

Sun Jan 24 16:31:36 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    public int handleGetNumOfPeers(){
        int numOfPeers = 0;

        System.out.println(peerTable.values().size());
//        for (Map.Entry<String, Double> me : set) {
//            me.getKey()
//            System.out.println(me.getValue());
//        }


        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());
                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();

                        }




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 16:33:54 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    public String handleGetPeers(){
        return peerTable.values().toString();
    }

    public int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());
                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            System.out.println(peers);
                        }




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 16:39:38 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    public String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peer -> {
            sb.append(peer);
            sb.append("\n");
        });
        return sb.toString();
    }

    public int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());
                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            System.out.println(peers);
                        }




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 16:41:00 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    public String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer);
                sb.append("\n");
            });
        });
        return sb.toString();
    }

    public int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());
                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            System.out.println(peers);
                        }




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 16:46:23 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source);
            sb.append("\n");
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = "Steve and Issack\n";
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());
                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();
                            System.out.println(sources);
                        }




                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 16:52:17 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source).append("\n");
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());
                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();
                        }





                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:03:31 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source).append("\n");
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        LocalDateTime dateAcquired = LocalDateTime.now();
                        System.out.println(dateAcquired);
//                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        timeTable.put(source, dateAcquired.toString());
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }





                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:06:07 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source).append("\n").append(timeTable.get(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        LocalDateTime dateAcquired = LocalDateTime.now();
                        String currDate = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss").format(LocalDateTime.now());
                        System.out.println(currDate);
//                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        timeTable.put(source, dateAcquired.toString());
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }

                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:06:38 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source).append("\n").append(timeTable.get(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        LocalDateTime dateAcquired = LocalDateTime.now();
                        String currDate = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        System.out.println(currDate);
//                        System.out.println(numberOfPeers);
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        timeTable.put(source, dateAcquired.toString());
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }

                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:11:12 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }

                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:11:44 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.println("Writing response: "+response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:14:45 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getRemoteSocketAddress().toString();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response: %s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:17:54 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 *
 *
 * Convert all string to string builder
 *
 * Extract any constants and store them as static final
 */

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().toString();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:18:28 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 *
 *
 * 1 ) Convert all string to string builder
 *
 * 2 ) Extract any constants and store them as static final at the top of the file
 *
 *
 */

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress().toString();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:18:43 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 *
 *
 * 1 ) Convert all string to string builder
 *
 * 2 ) Extract any constants and store them as static final at the top of the file
 *
 *
 */

public class Client {
    private String serverIP = "localhost";
    private int port = 12345;
    private static final String TEAM_NAME = "Steve and Issack\n";

    BufferedReader reader;
    BufferedWriter writer;

    ConcurrentHashMap<String, Set<String>> peerTable;
    ConcurrentHashMap<String, String> timeTable;



    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }


    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }
}

Sun Jan 24 17:41:42 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 */

public class Client {
    private final String serverIP;
    private final int port;
    private static final String TEAM_NAME = "Steve and Issack\n";

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = 12345;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        reader.close();
                        writer.close();
                        sock.close();
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }

        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);

    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:42:17 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 */

public class Client {
    private final String serverIP;
    private final int port;
    private static final String TEAM_NAME = "Steve and Issack\n";

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = 12345;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        reader.close();
                        writer.close();
//                        sock.close();
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }

        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);

    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:42:41 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 */

public class Client {
    private final String serverIP;
    private final int port;
    private static final String TEAM_NAME = "Steve and Issack\n";

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = 12345;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            while ((request = reader.readLine()) != null){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
//                        reader.close();
//                        writer.close();
                        sock.close();
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }

        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);

    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:45:14 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 */

public class Client {
    private final String serverIP;
    private final int port;
    private static final String TEAM_NAME = "Steve and Issack\n";

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = 12345;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:48:07 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 */

public class Client {
    private final String serverIP;
    private final int port;
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.println("Writing response now: " + response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.println(peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n%s\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:52:26 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 * 10 ) use her peer class
 */

/**
 * Insert class summary here, say what class does but not
 * @author Steve Khanna, Issack John 30031053
 */
public class Client {
    private final String serverIP;
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.printf("Writing response: {%s}\n" ,response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.printf("Peers received: {%s}\n",peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n{%s}\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer Successfully Closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket Successfully closed");
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:52:48 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 * 10 ) use her peer class
 */

/**
 * Insert class summary here, *say what class does but not how it does it*
 * @author Steve Khanna, Issack John 30031053
 */
public class Client {
    private final String serverIP;
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();
        System.out.println("Current relative path is: " + s);

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.printf("Writing response: {\n%s}\n" ,response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.printf("Peers received: {%s}\n",peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n{%s}\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer Successfully Closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket Successfully closed");
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:53:09 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 * 10 ) use her peer class
 */

/**
 * Insert class summary here, *say what class does but not how it does it*
 * @author Steve Khanna, Issack John 30031053
 */
public class Client {
    private final String serverIP;
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.printf("Writing response: {\n%s}\n" ,response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            System.out.println("Added: "+peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.printf("Peers received: {%s}\n",peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n{%s}\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer Successfully Closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket Successfully closed");
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:53:41 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 * 10 ) use her peer class
 */

/**
 * Insert class summary here, *say what class does but not how it does it*
 * @author Steve Khanna, Issack John 30031053
 */
public class Client {
    private final String serverIP;
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    /** Contains the sources and peers we know*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.printf("Writing response: {\n%s}\n" ,response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.printf("Peers received: {%s}\n",peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n{%s}\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer Successfully Closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket Successfully closed");
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:54:08 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 * 10 ) use her peer class
 */

/**
 * Insert class summary here, *say what class does but not how it does it*
 * @author Steve Khanna, Issack John 30031053
 */
public class Client {
    private final String serverIP;
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    /** Contains the sources and peers we know about, no duplicate sources or peers from sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.printf("Writing response: {\n%s}\n" ,response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.printf("Peers received: {\n%s}\n",peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n{%s}\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer Successfully Closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket Successfully closed");
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:54:20 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 * 10 ) use her peer class
 */

/**
 * Insert class summary here, *say what class does but not how it does it*
 * @author Steve Khanna, Issack John 30031053
 */
public class Client {
    private final String serverIP;
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    /** Contains the sources and peers we know about, no duplicate sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.printf("Writing response: {\n%s}\n" ,response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.printf("Peers received: {\n%s\n}\n",peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n{%s}\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer Successfully Closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket Successfully closed");
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Sun Jan 24 17:54:57 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) Convert all string to string builder
 * 2 ) Extract any constants and store them as static final at the top of the file
 * 3 ) JavaDoc on all functions and class
 * 4 ) Testcases, Junit
 * 5 ) Look for any places where exceptions might occur
 * 6 ) Run with multiple peers
 * 7 ) Getters and setters if needed
 * 8 ) Move variables that are shared to instance level and others to local level
 * 9 ) Separate cases into function and figure out proper name for methods
 * 10 ) use her peer class
 */

/**
 * Insert class summary here, *say what class does but not how it does it*
 * @author Steve Khanna, Issack John 30031053
 */
public class Client {
    private final String serverIP;
    /** Port number of registry */
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the registry, this port number will be used. */
    public static final int DEFAULT_PORT_NUMBER = 1245;

    private BufferedReader reader;
    private BufferedWriter writer;

    /** Contains the sources and peers we know about, no duplicate sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     *
     */
    public Client(){
        this.serverIP = "localhost";
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     *
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String handleGetCode(){

        String response = "";
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response = language+code+endOfCode;
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response;
    }

    /**
     *
     * @return
     */
    private String handleGetPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String handleGetPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfSources(){
        return peerTable.size();
    }

    /**
     *
     * @param source
     * @return
     */
    private int handleGetNumOfPeers(String source){
        return peerTable.get(source).size();
    }

    /**
     *
     * @return
     */
    private String handleGetSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(handleGetNumOfPeers(source))
                    .append("\n")
                    .append(handleGetPeers(source));
        });

        return sb.toString();
    }

    /**
     *
     * @return
     */
    private int handleGetNumOfPeers(){
        return peerTable.values().size();
    }

    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));
            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                String response = "";

                switch(request) {
                    case "get team name":
                        response = TEAM_NAME;
                        System.out.printf("Writing response: {\n%s}\n" ,response);
                        writer.write(response);
                        writer.flush();
                    break;
                    case "get code":
                        response = handleGetCode();
                        writer.write(response);
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        int numberOfPeers = Integer.parseInt(reader.readLine());
                        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
                        Set<String> peerList = Collections.synchronizedSet(new HashSet<String>());

                        while(numberOfPeers > 0){
                            String peer = reader.readLine();
                            peerList.add(peer);
                            numberOfPeers--;
                        }
                        String source = sock.getInetAddress().getHostAddress();
                        timeTable.put(source, dateAcquired);
                        if(!peerTable.containsKey(source)){
                            peerTable.put(source, peerList);
                        }
                        else{
                            Set<String> temp = peerTable.get(source);
                            temp.addAll(peerList);
                        }

                        System.out.printf("Peers received: {\n%s\n}\n",peerTable.toString());
                    break;
                    case "get report":
                        int numOfPeers = 0;
                        //newline peer peer
                        String peers = "";
                        int numOfSources = 0;
                        String sources = "";

                        if(peerTable.isEmpty()){
                            response = numOfPeers + "\n" + peers + "\n" + numOfSources + "\n" + sources +"\n";
                        }
                        else{
                            numOfPeers = handleGetNumOfPeers();
                            peers = handleGetPeers();
                            numOfSources = handleGetNumOfSources();
                            sources = handleGetSources();

                            response = numOfPeers + "\n" + peers + numOfSources + "\n" + sources;
                        }
                        System.out.printf("Writing response:\n{%s}\n", response);
                        writer.write(response);
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer successfully closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket successfully closed.");
    }

    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Wed Jan 27 17:43:34 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) TODO Convert all string to string builder
 * 2 ) TODO Extract any constants and store them as static final at the top of the file
 * 3 ) TODO JavaDoc on all functions and class
 * 5 ) TODO Look for any places where exceptions might occur
 * 6 ) TODO Run with multiple peers
 * 7 ) TODO Getters and setters if needed
 * 8 ) TODO Move variables that are shared to instance level and others to local level
 * 9 ) TODO Separate cases into function and figure out proper name for methods
 * 10 ) TODO ******use her peer class*****
 * 11 ) TODO change handle to get for all except the handleRequest method
 * 12 ) TODO Add local debugger instead of standard output.
 */

/**
 * Insert class summary here, *say what class does but not how it does it*
 * @author Steve and Issack - Steve Khanna 10153930, Issack John 30031053
 * @version 1.0
 * @since 01-20-2020
 */
public class Client {
    /** Server ip of registry */
    private final String serverIP;
    /** Port number of registry */
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the client, this port number will be used */
    public static final int DEFAULT_PORT_NUMBER = 1245;
    /** If no server ip is provided when running the client, this server ip will be used*/
    public static final String DEFAULT_SERVER_IP = "localhost";

    /** Contains the sources and peers we know about, no duplicate sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    /** Contains the time when the peerTable was acquire from a source, no duplicates allowed */
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     * Default class constructor
     * Initializes port, peerTable, and timeTable
     */
    public Client(){
        this.serverIP = DEFAULT_SERVER_IP;
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }

    /**
     * Overloaded class constructor
     * @param serverIP
     * @param port
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<String, Set<String>>();
        this.timeTable = new ConcurrentHashMap<String, String>();
    }


    /**
     *
     * @return
     */
    private String getCode(){

        StringBuilder response = new StringBuilder();
        String language = "java\n";

        // Simplify
        Path path = FileSystems.getDefault().getPath("src");
        String s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client");
        s = path.toAbsolutePath().toString();
        if (s.contains("/")){s+="/";}else{s+="\\";}
        path = FileSystems.getDefault().getPath(s+"Client.java");
        s = path.toAbsolutePath().toString();

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response.append(language).append(code).append(endOfCode);
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response.toString();
    }

    /**
     *
     * @return
     */
    private String getPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     *
     * @param source
     * @return
     */
    private String getPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     *
     * @return
     */
    private String getSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(peerTable.get(source).size())
                    .append("\n")
                    .append(getPeers(source));
        });

        return sb.toString();
    }

    /**
     * @param reader
     * @param source
     * @throws IOException
     */
    private void receivePeers(BufferedReader reader, String source) throws IOException {
        int numberOfPeers = Integer.parseInt(reader.readLine());
        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
        Set<String> peerList = Collections.synchronizedSet(new HashSet<>());

        while(numberOfPeers > 0){
            String peer = reader.readLine();
            peerList.add(peer);
            numberOfPeers--;
        }

        timeTable.put(source, dateAcquired);
        if(!peerTable.containsKey(source)){
            peerTable.put(source, peerList);
        }
        else{
            Set<String> temp = peerTable.get(source);
            temp.addAll(peerList);
        }
    }

    private String getReport(){
        StringBuilder report = new StringBuilder();
        int numOfPeers = peerTable.values().size();
        //newline peer peer
        String peers = (getPeers().equals("") ? "\n" : getPeers());
        int numOfSources = peerTable.size();
        String sources = (getSources().equals("") ? "\n" : getSources());

        report.append(numOfPeers)
                .append("\n")
                .append(peers)
                .append("\n")
                .append(numOfSources)
                .append("\n")
                .append(sources);

        return report.toString();
    }


    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));

            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                StringBuilder response = new StringBuilder();

                switch(request) {
                    case "get team name":
                        response.append(TEAM_NAME);
                        System.out.printf("Writing response: {\n%s}\n" ,response.toString());
                        writer.write(response.toString());
                        writer.flush();
                    break;
                    case "get code":
                        response.append(getCode());
                        writer.write(response.toString());
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    break;
                    case "receive peers":
                        receivePeers(reader, sock.getInetAddress().getHostAddress());
                        System.out.printf("Peers received: {\n%s\n}\n",peerTable.toString());
                    break;
                    case "get report":
                        response.append(getReport());
                        System.out.printf("Writing response:\n{%s}\n", response.toString());
                        writer.write(response.toString());
                        writer.flush();
                    break;

                    case "close":
                        System.out.println("Close Received");
                        done = true;
                    break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer successfully closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }

    public String getServerIP() {
        return serverIP;
    }

    public int getPort() {
        return port;
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket successfully closed.");
    }

    /**
     * Starts the client server
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55921
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Fri Jan 29 13:30:50 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 3 ) TODO JavaDoc on all functions and class
 * 12 ) TODO Add local debugger instead of standard output.
 */

/**
 * A peer process that con
 * @author Steve and Issack - Steve Khanna 10153930, Issack John 30031053
 * @version 1.0
 * @since 01-20-2020
 */
public class Client {
    /** Server ip of registry */
    private final String serverIP;
    /** Port number of registry */
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the client, this port number will be used */
    public static final int DEFAULT_PORT_NUMBER = 1245;
    /** If no server ip is provided when running the client, this server ip will be used*/
    public static final String DEFAULT_SERVER_IP = "localhost";

    /** Contains the sources and peers we know about, no duplicate sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    /** Contains the time when the peerTable was acquire from a source, no duplicates allowed */
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     * Default class constructor
     * Initializes port, peerTable, and timeTable
     */
    public Client(){
        this.serverIP = DEFAULT_SERVER_IP;
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }

    /**
     * Overloaded class constructor
     * @param serverIP the Ip for the registry
     * @param port the port for the registry
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }


    /**
     * Convert all source code for peer process to string
     * @return String response, all the source code as a string
     */
    private String getCode(){
        StringBuilder response = new StringBuilder();
        StringBuilder pathOfCode = new StringBuilder();
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src/Client/Client.java");
        pathOfCode.append(path.toAbsolutePath().toString());
        pathOfCode.append("/Client/Client.java");


        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response.append(language).append(code).append(endOfCode);
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response.toString();
    }

    /**
     * Grabs all the stored peers
     * @return string of peers with newline after each one
     */
    private String getPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     * Grabs all the peers for the source provides
     * @param source the source IP:port where the peers came from
     * @return a string of peers with newline after each one
     */
    private String getPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     * Grab all the known sources as well as their list of peers
     * @return list of sources as a string, the number of
     */
    private String getSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(peerTable.get(source).size())
                    .append("\n")
                    .append(getPeers(source));
        });

        return sb.toString();
    }

    /**
     * @param reader
     * @param source
     * @throws IOException
     */
    private void receivePeers(BufferedReader reader, String source) throws IOException {
        int numberOfPeers = Integer.parseInt(reader.readLine());
        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
        Set<String> peerList = Collections.synchronizedSet(new HashSet<>());

        while(numberOfPeers > 0){
            String peer = reader.readLine();
            peerList.add(peer);
            numberOfPeers--;
        }

        timeTable.put(source, dateAcquired);
        if(!peerTable.containsKey(source)){
            peerTable.put(source, peerList);
        }
        else{
            Set<String> temp = peerTable.get(source);
            temp.addAll(peerList);
        }
    }

    private String getReport(){
        StringBuilder report = new StringBuilder();
        String peers = (getPeers().equals("") ? "\n" : getPeers());
        String sources = (getSources().equals("") ? "\n" : getSources());

        report.append(peerTable.values().size()) //numOfPeers
                .append("\n")
                .append(peers)
                .append("\n")
                .append(peerTable.size()) //numOfSources
                .append("\n")
                .append(sources);

        return report.toString();
    }


    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));

            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                StringBuilder response = new StringBuilder();

                switch(request) {
                    case "get team name":
                        response.append(TEAM_NAME);
                        System.out.printf("Writing response: {\n%s}\n" ,response.toString());
                        writer.write(response.toString());
                        writer.flush();
                        break;
                    case "get code":
                        response.append(getCode());
                        writer.write(response.toString());
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                        break;
                    case "receive peers":
                        receivePeers(reader, sock.getInetAddress().getHostAddress());
                        System.out.printf("Peers received: {\n%s\n}\n",peerTable.toString());
                        break;
                    case "get report":
                        response.append(getReport());
                        System.out.printf("Writing response:\n{%s}\n", response.toString());
                        writer.write(response.toString());
                        writer.flush();
                        break;
                    case "close":
                        System.out.println("Close Received");
                        done = true;
                        break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer successfully closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }

    public String getServerIP() {
        return serverIP;
    }

    public int getPort() {
        return port;
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket successfully closed.");
    }

    /**
     * Starts the client server
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55901
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Fri Jan 29 13:31:37 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 3 ) TODO JavaDoc on all functions and class
 * 12 ) TODO Add local debugger instead of standard output.
 */

/**
 * A peer process that can receive peers as
 * @author Steve and Issack - Steve Khanna 10153930, Issack John 30031053
 * @version 1.0
 * @since 01-20-2020
 */
public class Client {
    /** Server ip of registry */
    private final String serverIP;
    /** Port number of registry */
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the client, this port number will be used */
    public static final int DEFAULT_PORT_NUMBER = 1245;
    /** If no server ip is provided when running the client, this server ip will be used*/
    public static final String DEFAULT_SERVER_IP = "localhost";

    /** Contains the sources and peers we know about, no duplicate sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    /** Contains the time when the peerTable was acquire from a source, no duplicates allowed */
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     * Default class constructor
     * Initializes port, peerTable, and timeTable
     */
    public Client(){
        this.serverIP = DEFAULT_SERVER_IP;
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }

    /**
     * Overloaded class constructor
     * @param serverIP the Ip for the registry
     * @param port the port for the registry
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }


    /**
     * Convert all source code for peer process to string
     * @return String response, all the source code as a string
     */
    private String getCode(){
        StringBuilder response = new StringBuilder();StringBuilder pathOfCode = new StringBuilder();
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src/Client/Client.java");
        pathOfCode.append(path.toAbsolutePath().toString());
        pathOfCode.append("/Client/Client.java");


        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response.append(language).append(code).append(endOfCode);
        }
        catch(IOException e){
            e.printStackTrace();
        }

        System.out.println(response);
        return response.toString();
    }

    /**
     * Grabs all the stored peers
     * @return string of peers with newline after each one
     */
    private String getPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     * Grabs all the peers for the source provides
     * @param source the source IP:port where the peers came from
     * @return a string of peers with newline after each one
     */
    private String getPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     * Grab all the known sources as well as their list of peers
     * @return list of sources as a string, the number of
     */
    private String getSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(peerTable.get(source).size())
                    .append("\n")
                    .append(getPeers(source));
        });

        return sb.toString();
    }

    /**
     * @param reader
     * @param source
     * @throws IOException
     */
    private void receivePeers(BufferedReader reader, String source) throws IOException {
        int numberOfPeers = Integer.parseInt(reader.readLine());
        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
        Set<String> peerList = Collections.synchronizedSet(new HashSet<>());

        while(numberOfPeers > 0){
            String peer = reader.readLine();
            peerList.add(peer);
            numberOfPeers--;
        }

        timeTable.put(source, dateAcquired);
        if(!peerTable.containsKey(source)){
            peerTable.put(source, peerList);
        }
        else{
            Set<String> temp = peerTable.get(source);
            temp.addAll(peerList);
        }
    }

    private String getReport(){
        StringBuilder report = new StringBuilder();
        String peers = (getPeers().equals("") ? "\n" : getPeers());
        String sources = (getSources().equals("") ? "\n" : getSources());

        report.append(peerTable.values().size()) //numOfPeers
                .append("\n")
                .append(peers)
                .append("\n")
                .append(peerTable.size()) //numOfSources
                .append("\n")
                .append(sources);

        return report.toString();
    }


    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));

            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                StringBuilder response = new StringBuilder();

                switch(request) {
                    case "get team name":
                        response.append(TEAM_NAME);
                        System.out.printf("Writing response: {\n%s}\n" ,response.toString());
                        writer.write(response.toString());
                        writer.flush();
                        break;
                    case "get code":
                        response.append(getCode());
                        writer.write(response.toString());
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                        break;
                    case "receive peers":
                        receivePeers(reader, sock.getInetAddress().getHostAddress());
                        System.out.printf("Peers received: {\n%s\n}\n",peerTable.toString());
                        break;
                    case "get report":
                        response.append(getReport());
                        System.out.printf("Writing response:\n{%s}\n", response.toString());
                        writer.write(response.toString());
                        writer.flush();
                        break;
                    case "close":
                        System.out.println("Close Received");
                        done = true;
                        break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer successfully closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }

    public String getServerIP() {
        return serverIP;
    }

    public int getPort() {
        return port;
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket successfully closed.");
    }

    /**
     * Starts the client server
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55901
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Fri Jan 29 13:33:41 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) TODO JavaDoc on all functions and class
 * 2 ) TODO Add local debugger instead of standard output.
 */

/**
 * A peer process that can receive peers from the registry as well as send a report on it's known sources and peers
 * @author Team: "Steve and Issack" - Steve Khanna 10153930, Issack John 30031053
 * @version 1.0
 * @since 01-29-2021
 */
public class Client {
    /** Server ip of registry */
    private final String serverIP;
    /** Port number of registry */
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the client, this port number will be used */
    public static final int DEFAULT_PORT_NUMBER = 1245;
    /** If no server ip is provided when running the client, this server ip will be used*/
    public static final String DEFAULT_SERVER_IP = "localhost";

    /** Contains the sources and peers we know about, no duplicate sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    /** Contains the time when the peerTable was acquire from a source, no duplicates allowed */
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     * Default class constructor
     * Initializes port, peerTable, and timeTable
     */
    public Client(){
        this.serverIP = DEFAULT_SERVER_IP;
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }

    /**
     * Overloaded class constructor
     * @param serverIP the Ip for the registry
     * @param port the port for the registry
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }


    /**
     * Convert all source code for peer process to string
     * @return String response, all the source code as a string
     */
    private String getCode(){
        StringBuilder response = new StringBuilder();
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src/Client/Client.java");

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response.append(language).append(code).append(endOfCode);
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response.toString();
    }

    /**
     * Grabs all the stored peers
     * @return string of peers with newline after each one
     */
    private String getPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     * Grabs all the peers for the source provides
     * @param source the source IP:port where the peers came from
     * @return a string of peers with newline after each one
     */
    private String getPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     * Grab all the known sources as well as their list of peers
     * @return list of sources as a string, the number of
     */
    private String getSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(peerTable.get(source).size())
                    .append("\n")
                    .append(getPeers(source));
        });

        return sb.toString();
    }

    /**
     * @param reader
     * @param source
     * @throws IOException
     */
    private void receivePeers(BufferedReader reader, String source) throws IOException {
        int numberOfPeers = Integer.parseInt(reader.readLine());
        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
        Set<String> peerList = Collections.synchronizedSet(new HashSet<>());

        while(numberOfPeers > 0){
            String peer = reader.readLine();
            peerList.add(peer);
            numberOfPeers--;
        }

        timeTable.put(source, dateAcquired);
        if(!peerTable.containsKey(source)){
            peerTable.put(source, peerList);
        }
        else{
            Set<String> temp = peerTable.get(source);
            temp.addAll(peerList);
        }
    }

    private String getReport(){
        StringBuilder report = new StringBuilder();
        String peers = (getPeers().equals("") ? "\n" : getPeers());
        String sources = (getSources().equals("") ? "\n" : getSources());

        report.append(peerTable.values().size()) //numOfPeers
                .append("\n")
                .append(peers)
                .append("\n")
                .append(peerTable.size()) //numOfSources
                .append("\n")
                .append(sources);

        return report.toString();
    }


    /**
     *
     * @param sock
     */
    private void handleRequest(Socket sock){

        try{
            BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));

            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                StringBuilder response = new StringBuilder();

                switch(request) {
                    case "get team name":
                        response.append(TEAM_NAME);
                        System.out.printf("Writing response: {\n%s}\n" ,response.toString());
                        writer.write(response.toString());
                        writer.flush();
                        break;
                    case "get code":
                        response.append(getCode());
                        writer.write(response.toString());
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                        break;
                    case "receive peers":
                        receivePeers(reader, sock.getInetAddress().getHostAddress());
                        System.out.printf("Peers received: {\n%s\n}\n",peerTable.toString());
                        break;
                    case "get report":
                        response.append(getReport());
                        System.out.printf("Writing response:\n{%s}\n", response.toString());
                        writer.write(response.toString());
                        writer.flush();
                        break;
                    case "close":
                        System.out.println("Close Received");
                        done = true;
                        break;
                    default:
                        System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer successfully closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }

    public String getServerIP() {
        return serverIP;
    }

    public int getPort() {
        return port;
    }


    /**
     *
     * @throws IOException
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket successfully closed.");
    }

    /**
     * Starts the client server. If a port nubmer is provided as
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55901
        if (args.length != 2) {
            System.out.println("Number of arguments is not valid. Usage: Server IP, port");
            System.exit(1);
        }
        try {
            Client client = new Client(args[0], Integer.parseInt(args[1]));
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Fri Jan 29 13:46:01 MST 2021
java
package Client;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 1 ) TODO JavaDoc on all functions and class
 * 2 ) TODO Add local debugger instead of standard output.
 */

/**
 * A peer process that can receive peers from the registry as well as send a report on it's known sources and peers
 * @author Team: "Steve and Issack" - Steve Khanna 10153930, Issack John 30031053
 * @version 1.0 (Iteration 1)
 * @since 01-29-2021
 */
public class Client {
    /** Server ip of registry */
    private final String serverIP;
    /** Port number of registry */
    private final int port;
    /** Our team name */
    private static final String TEAM_NAME = "Steve and Issack\n";
    /** If no port number is provided when running the client, this port number will be used */
    public static final int DEFAULT_PORT_NUMBER = 1245;
    /** If no server ip is provided when running the client, this server ip will be used*/
    public static final String DEFAULT_SERVER_IP = "localhost";

    /** Contains the sources and peers we know about, no duplicate sources*/
    private final ConcurrentHashMap<String, Set<String>> peerTable;
    /** Contains the time when the peerTable was acquire from a source, no duplicates allowed */
    private final ConcurrentHashMap<String, String> timeTable;

    /**
     * Default class constructor
     * Initializes port, peerTable, and timeTable
     */
    public Client(){
        this.serverIP = DEFAULT_SERVER_IP;
        this.port = DEFAULT_PORT_NUMBER;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }

    /**
     * Overloaded class constructor
     * @param serverIP the Ip for the registry
     * @param port the port for the registry
     */
    public Client(String serverIP, int port){
        this.serverIP = serverIP;
        this.port = port;
        this.peerTable = new ConcurrentHashMap<>();
        this.timeTable = new ConcurrentHashMap<>();
    }


    /**
     * Convert all source code for peer process to string
     * @return String response, all the source code as a string
     */
    private String getCode(){
        StringBuilder response = new StringBuilder();
        String language = "java\n";

        Path path = FileSystems.getDefault().getPath("src/Client/Client.java");

        try{
            String code = Files.readString(path, StandardCharsets.UTF_8)+"\n";
            String endOfCode = "...\n";
            response.append(language).append(code).append(endOfCode);
        }
        catch(IOException e){
            e.printStackTrace();
        }

        return response.toString();
    }

    /**
     * Grabs all the stored peers
     * @return string of peers with newline after each one
     */
    private String getPeers(){
        StringBuilder sb = new StringBuilder();
        peerTable.values().forEach(peerList -> {
            peerList.forEach(peer -> {
                sb.append(peer).append("\n");
            });
        });
        return sb.toString();
    }

    /**
     * Grabs all the peers for the source provides
     * @param source the source IP:port where the peers came from
     * @return a string of peers with newline after each one
     */
    private String getPeers(String source){
        StringBuilder sb = new StringBuilder();
        peerTable.get(source).forEach(peer -> {
                sb.append(peer).append("\n");
        });
        return sb.toString();
    }

    /**
     * Grab all the known sources as well as their peers
     * @return String, the sources as a string, the number of sources as well as the peers
     */
    private String getSources(){
        StringBuilder sb = new StringBuilder();
        peerTable.keySet().forEach(source -> {
            sb.append(source)
                    .append("\n")
                    .append(timeTable.get(source))
                    .append("\n")
                    .append(peerTable.get(source).size())
                    .append("\n")
                    .append(getPeers(source));
        });

        return sb.toString();
    }

    /**
     * receive a list of peers from the registry and store them
     * @param reader socket to read the peers from
     * @param source for storing the peers with their source
     * @throws IOException if there is a problem communicating with the registry
     */
    private void receivePeers(BufferedReader reader, String source) throws IOException {
        int numberOfPeers = Integer.parseInt(reader.readLine());
        String dateAcquired = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());
        Set<String> peerList = Collections.synchronizedSet(new HashSet<>());

        while(numberOfPeers > 0){
            String peer = reader.readLine();
            peerList.add(peer);
            numberOfPeers--;
        }

        timeTable.put(source, dateAcquired);
        if(!peerTable.containsKey(source)){
            peerTable.put(source, peerList);
        }
        else{
            Set<String> temp = peerTable.get(source);
            temp.addAll(peerList);
        }
    }

    /**
     * handle the get report request, getting the sources and their peers as a string
     * @return String, information on the sources, peers and how many peers their are
     */
    private String getReport(){
        StringBuilder report = new StringBuilder();
        String peers = (getPeers().equals("") ? "\n" : getPeers());
        String sources = (getSources().equals("") ? "\n" : getSources());

        report.append(peerTable.values().size()) //numOfPeers
                .append("\n")
                .append(peers)
                .append("\n")
                .append(peerTable.size()) //numOfSources
                .append("\n")
                .append(sources);

        return report.toString();
    }


    /**
     * handling the communication between the peer process and the registry server
     * based on the communication protocol
     * @param sock the socket where the client is connected to the registry for all necessary communication
     */
    private void handleRequest(Socket sock){

        try{
            BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));

            String request;
            boolean done = false;
            while ((request = reader.readLine()) != null && !done){
                System.out.println(request);
                StringBuilder response = new StringBuilder();

                switch (request) {
                    case "get team name" -> {
                        response.append(TEAM_NAME);
                        System.out.printf("Writing response: {\n%s}\n", response.toString());
                        writer.write(response.toString());
                        writer.flush();
                    }
                    case "get code" -> {
                        response.append(getCode());
                        writer.write(response.toString());
                        writer.flush();
                        System.out.println("Code Written Successfully.");
                    }
                    case "receive peers" -> {
                        receivePeers(reader, sock.getInetAddress().getHostAddress());
                        System.out.printf("Peers received: {\n%s\n}\n", peerTable.toString());
                    }
                    case "get report" -> {
                        response.append(getReport());
                        System.out.printf("Writing response:\n{%s}\n", response.toString());
                        writer.write(response.toString());
                        writer.flush();
                    }
                    case "close" -> {
                        System.out.println("Close Received");
                        done = true;
                    }
                    default -> System.out.println("Request not recognized");
                }
            }
            reader.close();
            writer.close();
            System.out.println("Reader and Writer successfully closed.");
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }

    /**
     * get the server ip
     * @return string server ip
     */
    public String getServerIP() {
        return serverIP;
    }

    /**
     * get the port
     * @return int port
     */
    public int getPort() {
        return port;
    }


    /**
     * Starts the peer and accepts requests from registry.
     * @throws IOException if there are problems starting this peer or
     * if there are problems communicating with the registry.
     */
    public void start() throws IOException{
        Socket sock = new Socket(serverIP, port);
        handleRequest(sock);
        sock.close();
        System.out.println("Socket successfully closed.");
    }

    /**
     * Starts the client server. If a port number is provided as a runtime argument,
     * it will be used to start the peer.
     * @param args
     */
    public static void main(String[] args) {
        //Server IP = 136.159.5.22
        //Port: 55901

        try {
            Client client;
            if (args.length != 2) {
                System.out.println("No Server IP and port provided. Using Default Constructor with: localhost:12345");
                client = new Client();
            }
            else{
                client = new Client(args[0], Integer.parseInt(args[1]));
            }
            client.start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

